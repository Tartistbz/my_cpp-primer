## C++ 字面值类型对照表

### 1. 字符字面值（Character Literals）

| 形式   | 类型       | 示例   | 说明                   |
| ------ | ---------- | ------ | ---------------------- |
| `'a'`  | `char`     | `'a'`  | 单个字符               |
| `L'a'` | `wchar_t`  | `L'a'` | 宽字符（宽字符集）     |
| `u'a'` | `char16_t` | `u'a'` | UTF-16 字符            |
| `U'a'` | `char32_t` | `U'a'` | UTF-32 字符            |
| `'\n'` | `char`     | `'\n'` | 转义序列（换行）       |
| `\x4d` | `char`     | `\x4d` | 十六进制转义（字符 M） |
| `\115` | `char`     | `\115` | 八进制转义（字符 M）   |

---

### 2. 字符串字面值（String Literals）

| 形式     | 类型                | 示例     | 说明                            |
| -------- | ------------------- | -------- | ------------------------------- |
| `"hi"`   | `const char[3]`     | `"hi"`   | 普通字符串（末尾自动加 `'\0'`） |
| `L"hi"`  | `const wchar_t[3]`  | `L"hi"`  | 宽字符串                        |
| `u8"hi"` | `const char[3]`     | `u8"hi"` | UTF-8 编码字符串                |
| `u"hi"`  | `const char16_t[3]` | `u"hi"`  | UTF-16 字符串                   |
| `U"hi"`  | `const char32_t[3]` | `U"hi"`  | UTF-32 字符串                   |

---

### 3. 整数字面值（Integer Literals）

| 形式                     | 类型（默认）       | 示例    | 说明                   |
| ------------------------ | ------------------ | ------- | ---------------------- |
| 十进制                   | `int`              | `42`    | 默认是 `int`           |
| 八进制（前缀 0）         | `int`              | `042`   | 0 开头表示八进制       |
| 十六进制（前缀 0x / 0X） | `int`              | `0x2A`  | 0x 开头表示十六进制    |
| 后缀 `u` / `U`           | 无符号类型         | `42u`   | unsigned int           |
| 后缀 `l` / `L`           | long               | `42L`   | long int               |
| 后缀 `ul` / `UL`         | unsigned long      | `42UL`  | unsigned long int      |
| 后缀 `ll` / `LL`         | long long          | `42LL`  | long long int          |
| 后缀 `ull` / `ULL`       | unsigned long long | `42ULL` | unsigned long long int |

---

### 4. 浮点字面值（Floating-point Literals）

| 形式           | 类型（默认） | 示例    | 说明         |
| -------------- | ------------ | ------- | ------------ |
| 小数形式       | `double`     | `3.14`  | 默认 double  |
| 科学计数法     | `double`     | `1e-3`  | 1 × 10^-3    |
| 后缀 `f` / `F` | float        | `3.14f` | 单精度浮点   |
| 后缀 `l` / `L` | long double  | `3.14L` | 扩展精度浮点 |

---

### 5. 布尔与指针字面值

| 形式      | 类型             | 示例      | 说明   |
| --------- | ---------------- | --------- | ------ |
| `true`    | `bool`           | `true`    | 布尔真 |
| `false`   | `bool`           | `false`   | 布尔假 |
| `nullptr` | `std::nullptr_t` | `nullptr` | 空指针 |

---

📌 **记忆技巧**

* **前缀** 改变字符/字符串的编码类型（`L` 宽，`u8` UTF-8，`u` UTF-16，`U` UTF-32）。
* **后缀** 改变整数/浮点的精度与符号类型（`u` 无符号，`l` 长整型，`f` 单精度浮点）。
* 没有前缀/后缀时，整数默认 `int`，浮点默认 `double`，字符默认 `char`，字符串默认 `const char[]`。

这个现象是因为 **C++11 以后引入的列表初始化（花括号初始化）对窄化转换（narrowing conversion）做了严格限制**。我帮你详细解释一下：

---
# 变量初始化
## 1. 变量初始化方式

* `int a{ld};` 和 `int b = {ld};` 是 **列表初始化（brace-init-list）**
* `int c(ld);` 和 `int d = ld;` 是 **直接初始化** 和 **拷贝初始化**

---

## 2. 什么是窄化转换（Narrowing conversion）？

窄化转换指的是 **从一种类型转换成另一种类型时，可能导致数据精度丢失或者范围溢出的转换**。

* 例如：`long double` 转换成 `int` 会丢失小数部分（精度）和可能范围外的值。

---

## 3. C++11 列表初始化对窄化转换的限制

* **用花括号初始化时，如果会发生窄化转换，编译器必须报错**，防止不小心丢失信息。
* 这是为了避免潜在的隐式错误，提高代码安全性。

---

## 4. 你写的代码行为分析

```cpp
long double ld = 3.1415926536;
int a{ld};     // 错误！列表初始化禁止窄化转换
int b = {ld};  // 错误！同上

int c(ld);     // 正确，直接初始化，允许窄化转换，丢失精度
int d = ld;    // 正确，拷贝初始化，允许窄化转换，丢失精度
```

---

## 5. 总结

| 初始化方式      | 是否允许窄化转换 | 备注          |
| ---------- | -------- | ----------- |
| 列表初始化 `{}` | 不允许      | 编译错误，防止丢失信息 |
| 直接初始化 `()` | 允许       | 会丢失精度       |
| 拷贝初始化 `=`  | 允许       | 会丢失精度       |

---

如果你想避免这类错误，且确认要转换，可以显式使用 `static_cast`，比如：

```cpp
int a = static_cast<int>(ld);  // 明确告诉编译器我知道可能丢失
```


